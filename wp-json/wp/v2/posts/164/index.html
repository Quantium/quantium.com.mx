{"id":164,"date":"2008-05-06T19:38:39","date_gmt":"2008-05-07T00:38:39","guid":{"rendered":"http:\/\/www.quantium.com.mx\/qlog\/?p=164"},"modified":"2011-07-18T17:59:04","modified_gmt":"2011-07-18T22:59:04","slug":"sockets-binarios-actionscript-3-java","status":"publish","type":"post","link":"http:\/\/www.quantium.com.mx\/2008\/05\/06\/sockets-binarios-actionscript-3-java\/","title":{"rendered":"Sockets Binarios, ActionScript 3 + Java"},"content":{"rendered":"<p>De las preguntas que m\u00e1s me hacen es como conectar un socket con actionscript. El problema generalmente es que muchos tienen el c\u00f3digo correcto para conectarse en ActionScript pero no lo tienen del lado del servidor. Aqu\u00ed pongo un ejemplo sencillo, 2 proyectos para eclipse uno en Java que es una versi\u00f3n sencilla de un servidor que crea un socket en el puerto 9999 y el otro proyecto en ActionScript para conectarse a este socket.<\/p>\n<p>Lo primero que necesitamos es tener el <a href=\"http:\/\/www.eclipse.org\/downloads\/download.php?file=\/eclipse\/downloads\/drops\/R-3.3.2-200802211800\/eclipse-SDK-3.3.2-win32.zip\" target=\"_blank\">eclipse <\/a>instalado as\u00ed como el <a href=\"http:\/\/www.adobe.com\/cfusion\/entitlement\/index.cfm?e=flex3email\" target=\"_blank\">plugin de flex para eclipse.<\/a><\/p>\n<p>Una vez hecho esto creamos 2 proyectos un proyecto Java que llamaremos <span style=\"text-decoration: line-through;\">QuantiumBinaryConnectionToFlashPlayerBuildedInFlex<\/span>Socket.<\/p>\n<p>Creamos una clase llamada simpleServer que va a ser nuestra clase principal, osea donde va a estar nuestro m\u00e9todo main.<\/p>\n<p>Por la simplicidad de este ejemplo no vamos a hacer un socket complejo, de hecho s\u00f3lo escribiremos unas cuantas l\u00edneas de c\u00f3digo en la funci\u00f3n main.<\/p>\n<p>Empezamos creando una variable de tipo <em>char<\/em> que representar\u00e1 el <em>End Of Line<\/em> de nuestos mensajes, esto es porque es el caracter que le indica al player que el mensaje ha terminado:<\/p>\n<p><code><br \/>\nchar EOF = (char)0x00;<br \/>\n<\/code><\/p>\n<p>Despu\u00e9s, en nuestra funcion main abrimos un try en donde correr\u00e1 nuestro socket, utilizando las clases <em>ServerSocket <\/em>y <em>Socket<\/em> y abriendo una conexi\u00f3n en el puerto 9999, tomando el catch para saber que la sesi\u00f3n ha terminado:<\/p>\n<p><code><br \/>\ntry<br \/>\n{<br \/>\n\/\/ create a serverSocket connection on port 9999<br \/>\nServerSocket s = new ServerSocket(9999);<br \/>\nString msgstr = \"\";<\/code><\/p>\n<p>System.out.println(&#8220;Servidor iniciado. Esperando conexi\u00f3n del cliente&#8230;&#8221;);<br \/>\n\/\/ wait for incoming connections<br \/>\nSocket incoming = s.accept();<\/p>\n<p>BufferedReader data_in = new BufferedReader(<br \/>\nnew InputStreamReader(incoming.getInputStream()));<br \/>\nPrintWriter data_out = new PrintWriter(incoming.getOutputStream());<br \/>\n}<br \/>\ncatch (Exception e)<br \/>\n{<br \/>\nSystem.out.println(&#8220;Conexi\u00f3n terminada&#8221;);<br \/>\n}<\/p>\n<p>Una vez creada nuestra conecci\u00f3n, creamos un blucle que estar\u00e1 verificando si se recibe alg\u00fan mensaje, y en caso de que la conexi\u00f3n termine se rompa el bucle:<\/p>\n<p><code><br \/>\nboolean quit = false;<\/code><\/p>\n<p>while (!quit)<br \/>\n{<br \/>\nString msg = data_in.readLine();<\/p>\n<p>if (msg == null) quit = true;<br \/>\n}<\/p>\n<p>&nbsp;<\/p>\n<p>Finalmente agregamos un peque\u00f1o condicional que verificar\u00e1 si el mensaje enviado es salir y en caso de que lo sea termina el bucle, terminando as\u00ed la ejecuci\u00f3n del programa; y en caso contrario que regrese el mismo mensaje que ha sido recibido:<\/p>\n<p><code><br \/>\nif (msg.trim().equals(\"salir\"))<br \/>\n{<br \/>\ndata_out.println(\"Adios\"+EOF);<br \/>\ndata_out.flush();<br \/>\nquit = true;<\/code><\/p>\n<p>}<br \/>\nelse<br \/>\n{<br \/>\ndata_out.println(msgstr+EOF);<br \/>\ndata_out.flush();<br \/>\n}<\/p>\n<p>Esto es todo lo que necesitamos hacer para tener nuestro servidor local para probar nuestro socket.<\/p>\n<p>Ahora vamos con ActionScript.<\/p>\n<p>Creamos un proyecto Flex AIR\u00ae que llamar\u00e9 <span style=\"text-decoration: line-through;\">por puro gusto egocentrista<\/span> QChat. En nuestro <span style=\"text-decoration: line-through;\">asqueroso<\/span> MXML agregamos un TextArea, un TextInput y un Button.<\/p>\n<p>Luego creamos la clase que se conectar\u00e1 a nuestro servidor llamada ChatSocket. Dicha clase ser\u00e1 hija de la clase <a href=\"http:\/\/livedocs.adobe.com\/flex\/3\/langref\/flash\/net\/Socket.html\" target=\"_blank\">Socket.<\/a><\/p>\n<p>Creamos una variable de tipo string a la cual llamaremos response que guardar\u00e1 toda la historia de mensajes recibidos.<\/p>\n<p>&nbsp;<\/p>\n<p>private var response:String;<\/p>\n<p>&nbsp;<\/p>\n<p>En el constructor de nuestra clase vamos a inicializar al constructor del padre y llamar a la funci\u00f3n <span style=\"text-decoration: line-through;\">seg\u00fan la escuela de los evangelistas de adobe<\/span> que inicializa los l\u00edsteners de nuestro socket.<\/p>\n<p><code><br \/>\npublic function ChatSocket(host:String=null, port:int=0)<br \/>\n{<br \/>\nsuper(host, port);<br \/>\nconfigureListeners();<br \/>\n}<br \/>\nprivate function configureListeners():void<br \/>\n{<br \/>\naddEventListener(Event.CLOSE, closeHandler);<br \/>\naddEventListener(Event.CONNECT, connectHandler);<br \/>\naddEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);<br \/>\naddEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);<br \/>\naddEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler);<br \/>\n}<\/code><\/p>\n<p>private function closeHandler(event:Event):void<br \/>\n{<br \/>\ntrace(&#8220;closeHandler: &#8221; + event);<br \/>\n}<\/p>\n<p>private function connectHandler(event:Event):void<br \/>\n{<br \/>\ntrace(&#8220;connectHandler: &#8221; + event);<br \/>\n}<\/p>\n<p>private function ioErrorHandler(event:IOErrorEvent):void<br \/>\n{<br \/>\ntrace(&#8220;ioErrorHandler: &#8221; + event);<br \/>\n}<\/p>\n<p>private function securityErrorHandler(event:SecurityErrorEvent):void<br \/>\n{<br \/>\ntrace(&#8220;securityErrorHandler: &#8221; + event);<br \/>\n}<\/p>\n<p>private function socketDataHandler(event:ProgressEvent):void<br \/>\n{<br \/>\ntrace(&#8220;socketDataHandler: &#8221; + event);<br \/>\n}<\/p>\n<p>&nbsp;<\/p>\n<p>Hasta aqu\u00ed vamos bien<span style=\"text-decoration: line-through;\">, si no has entendido nada pulsa Alt+F4<\/span>.<\/p>\n<p>Ahora crearemos una Clase que nos servir\u00e1 como utilidad <a href=\"http:\/\/es.wikipedia.org\/wiki\/Ortogonal\" target=\"_blank\">ortogonal<\/a> para nuestro proyecto. Osease que vamos a crear un hijo de la clase <a href=\"http:\/\/livedocs.adobe.com\/flex\/3\/langref\/flash\/events\/Event.html\" target=\"_blank\">Event<\/a> que se llamar\u00e1 ChatSocketEvent. Este tipo de eventos<span style=\"text-decoration: line-through;\"> por el momento s\u00f3lo<\/span> ser\u00e1n despachados al momento de recibir un mensaje.<\/p>\n<p><code><br \/>\npublic static const RESPONSE:String = \"response\";<\/code><\/p>\n<p>protected var _message:String;<br \/>\npublic function get message():String<br \/>\n{<br \/>\nreturn _message;<br \/>\n}<br \/>\npublic function ChatSocketEvent($type:String, $message:String, $bubbles:Boolean=false, $cancelable:Boolean=false)<br \/>\n{<br \/>\n_message = $message;<br \/>\nsuper($type, $bubbles, $cancelable);<br \/>\n}<\/p>\n<p>Una vez creado nuestro evento vamos a utilizarlo para enviar el mensaje recibido en la funci\u00f3n socketDataHandler en nuestra Clase ChatSocket.<\/p>\n<p><code><br \/>\nprivate function socketDataHandler(event:ProgressEvent):void<br \/>\n{<br \/>\nvar str:String = readUTFBytes(bytesAvailable);<br \/>\ndispatchEvent(new ChatSocketEvent(ChatSocketEvent.RESPONSE,str));<br \/>\nresponse += str;<br \/>\n}<br \/>\n<\/code><\/p>\n<p>Ahora que ya leemos la respuesta del servidor vamos a hacer un m\u00e9todo que se encargue de enviar datos llamado say, en este m\u00e9todo escribimos los bytes en modo UTF en el socket y hacemos flush, todo esto dentro de un try para cachar cualquier error:<\/p>\n<p><code><br \/>\npublic function say($message:String):void<br \/>\n{<br \/>\nresponse = \"\";<br \/>\n$message += \"\\n\";<br \/>\ntry {<br \/>\nwriteUTFBytes($message);<br \/>\n}<br \/>\ncatch(e:IOError) {<br \/>\ntrace(e);<br \/>\n}<br \/>\nflush();<br \/>\n}<\/code><\/p>\n<p>&nbsp;<\/p>\n<p>Ahora regresemos a nuestro horroroso MXML.<\/p>\n<p>Creamos la variable _localSocket que ser\u00e1 una instancia de nuestra clase ChatSocket<\/p>\n<p><code><br \/>\nprivate var _localSocket:ChatSocket = new ChatSocket();<br \/>\n<\/code><\/p>\n<p>Vamos agregar un m\u00e9todo que escuche el evento de inicializaci\u00f3n de nuestro AIR, en el cual inicializaremos el socket y agregaremos el evento que escuchar\u00e1 al teclado <span style=\"text-decoration: line-through;\">para que en el momento de presionar enter se env\u00eden los mensajes<\/span>, dentro del evento ponemos:<\/p>\n<p><code><br \/>\n_localSocket.addEventListener(ChatSocketEvent.RESPONSE, serverResponse);<br \/>\n_localSocket.connect(\"localhost\", 9999);<br \/>\naddEventListener(KeyboardEvent.KEY_DOWN, keyDown);<br \/>\n<\/code><\/p>\n<p>Como podemos ver hemos creado dos m\u00e9todos: serverResponse y keyDown. serverResponse escucha los eventos tirados por nuestro socket y los env\u00eda a nuestro TextArea y keyDown escucha cuando el usuario presiona enter y env\u00eda el mensaje <span style=\"text-decoration: line-through;\">viva la usabilidad<\/span>.<\/p>\n<p><code><br \/>\nprotected function serverResponse($evt:ChatSocketEvent):void<br \/>\n{<br \/>\nconsole.text += \"Server :: \"+$evt.message+\"\\n\";<br \/>\n}<br \/>\nprotected function keyDown($evt:KeyboardEvent):void<br \/>\n{<br \/>\nif($evt.keyCode == Keyboard.ENTER)<br \/>\n{<br \/>\nsendChat();<br \/>\n}<br \/>\n}<\/code><\/p>\n<p>&nbsp;<\/p>\n<p>El evento sendChat que es llamado al presionar ENTER tambi\u00e9n ser\u00e1 llamado al presionar el bot\u00f3n que tenemos en nuestro <span style=\"text-decoration: line-through;\">purulento <\/span>MXML.<\/p>\n<p><code><br \/>\npublic function sendChat():void<br \/>\n{<br \/>\n_localSocket.say(input.text);<br \/>\nconsole.text += \"Quantium :: \"+input.text+\"\\n\";<br \/>\ninput.text = \"\";<br \/>\n}<br \/>\n<\/code><\/p>\n<p>Para hacer las llamadas desde nuestro componentes hacemos algo como esto:<br \/>\n&lt;mx:TextArea id=&#8221;console&#8221; width=&#8221;100%&#8221; height=&#8221;100%&#8221;\/&gt;<\/p>\n<p>&lt;mx:TextInput id=&#8221;input&#8221; width=&#8221;85%&#8221;\/&gt;<\/p>\n<p>&lt;mx:Button id=&#8221;send&#8221; label=&#8221;Button&#8221; width=&#8221;10%&#8221; textAlign=&#8221;center&#8221; click=&#8221;sendChat()&#8221;\/&gt;<\/p>\n<p>Y listo, ya est\u00e1 nuestro peque\u00f1o Chat. Para probar su funcionamiento puedes descargar <span style=\"text-decoration: line-through;\">o ejecutar<\/span> <a href=\"http:\/\/www.quantium.com.mx\/qchat\/simpleServer.jar\" target=\"_blank\">el archivo .jar aqu\u00ed<\/a>.<\/p>\n<p>Y para descargar la aplicaci\u00f3n AIR lo puedes hacer aqu\u00ed abajo:<\/p>\n<div>\n<div class=\"QChatAIR\">\n<div class=\"youtube-video\"><object id=\"badge\" width=\"217\" height=\"180\" classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" codebase=\"http:\/\/download.macromedia.com\/pub\/shockwave\/cabs\/flash\/swflash.cab#version=6,0,40,0\"><param name=\"allowScriptAccess\" value=\"sameDomain\" \/><param name=\"allowFullScreen\" value=\"false\" \/><param name=\"menu\" value=\"false\" \/><param name=\"quality\" value=\"high\" \/><param name=\"src\" value=\"http:\/\/www.quantium.com.mx\/qchat\/badge.swf\" \/><param name=\"allowfullscreen\" value=\"false\" \/><param name=\"allowscriptaccess\" value=\"sameDomain\" \/><embed id=\"badge\" width=\"217\" height=\"180\" type=\"application\/x-shockwave-flash\" src=\"http:\/\/www.quantium.com.mx\/qchat\/badge.swf\" allowScriptAccess=\"sameDomain\" allowFullScreen=\"false\" menu=\"false\" quality=\"high\" allowfullscreen=\"false\" allowscriptaccess=\"sameDomain\" \/><\/object><\/div>\n<\/div>\n<\/div>\n<p>Importante: El air no funcionar\u00e1 si el jar no est\u00e1 ya corriendo cuando se ejecute. Primero ejecuta el archivo simpleServer.jar y despu\u00e9s el air.<\/p>\n<p><strong>\u00bfTe gustar\u00eda tener los archivos fuente de este ejemplo completos y listos para correrse desde eclipse?<\/strong><\/p>\n<p><strong>\u00a1\u00a1\u00a1Adquiere los Archivos de este tutorial!!<\/strong><\/p>\n<form action=\"https:\/\/www.paypal.com\/cgi-bin\/webscr\" method=\"post\"><input type=\"hidden\" name=\"cmd\" value=\"_xclick\" \/><\/p>\n<p><input type=\"hidden\" name=\"business\" value=\"quantium@gmail.com\" \/><\/p>\n<p><input type=\"hidden\" name=\"item_name\" value=\"Sockets Binarios-ActionScript 3 + Java source code\" \/><\/p>\n<p><input type=\"hidden\" name=\"amount\" value=\"5.00\" \/><\/p>\n<p><input type=\"hidden\" name=\"page_style\" value=\"Primary\" \/><\/p>\n<p><input type=\"hidden\" name=\"no_shipping\" value=\"1\" \/><\/p>\n<p><input type=\"hidden\" name=\"image_url\" value=\"QuantiumLogo.jpg\" \/><\/p>\n<p><input type=\"hidden\" name=\"cn\" value=\"Comentarios\" \/><\/p>\n<p><input type=\"hidden\" name=\"currency_code\" value=\"USD\" \/><\/p>\n<p><input type=\"hidden\" name=\"lc\" value=\"MX\" \/><\/p>\n<p><input type=\"hidden\" name=\"bn\" value=\"PP-BuyNowBF\" \/><\/p>\n<p><input type=\"image\" name=\"submit\" src=\"https:\/\/www.paypal.com\/es_XC\/i\/btn\/x-click-but01.gif\" alt=\"PayPal - The safer, easier way to pay online!\" \/><\/p>\n<p><img loading=\"lazy\" src=\"https:\/\/www.paypal.com\/es_XC\/i\/scr\/pixel.gif\" alt=\"\" width=\"1\" height=\"1\" border=\"0\" \/><\/p>\n<\/form>\n<p>solo 5 d\u00f3lares<\/p>\n","protected":false},"excerpt":{"rendered":"<p>De las preguntas que m\u00e1s me hacen es como conectar un socket con actionscript. El problema generalmente es que muchos tienen el c\u00f3digo correcto para conectarse en ActionScript pero no lo tienen del lado del servidor. Aqu\u00ed pongo un ejemplo sencillo, 2 proyectos para eclipse uno en Java que es una versi\u00f3n sencilla de un [&hellip;]<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[7,1],"tags":[],"_links":{"self":[{"href":"http:\/\/www.quantium.com.mx\/wp-json\/wp\/v2\/posts\/164"}],"collection":[{"href":"http:\/\/www.quantium.com.mx\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/www.quantium.com.mx\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/www.quantium.com.mx\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/www.quantium.com.mx\/wp-json\/wp\/v2\/comments?post=164"}],"version-history":[{"count":0,"href":"http:\/\/www.quantium.com.mx\/wp-json\/wp\/v2\/posts\/164\/revisions"}],"wp:attachment":[{"href":"http:\/\/www.quantium.com.mx\/wp-json\/wp\/v2\/media?parent=164"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/www.quantium.com.mx\/wp-json\/wp\/v2\/categories?post=164"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/www.quantium.com.mx\/wp-json\/wp\/v2\/tags?post=164"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}